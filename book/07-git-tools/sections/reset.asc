[[_git_reset]]
=== Reset Demystified

Before moving on to more specialized tools, let's talk about `reset` and `checkout`.
These commands are two of the most confusing parts of Git when you first encounter them.
They do so many things, that it seems hopeless to actually understand them and employ them properly.
For this, we recommend a simple metaphor.

==== The Three Trees

An easier way to think about `reset` and `checkout` is through the mental frame of Git being a content manager of three different trees.
By ``tree'' here we really mean ``collection of files'', not specifically the data structure.
(There are a few cases where the index doesn't exactly act like a tree, but for our purposes it is easier to think about it this way for now.)

Git as a system manages and manipulates three trees in its normal operation:

[cols="1,2",options="header"]
|================================
| Tree              | Role
| HEAD              | Last commit snapshot, next parent
| Index             | Proposed next commit snapshot
| Working Directory | Sandbox
|================================

===== The HEAD

HEAD is the pointer to the current branch reference, which is in turn a pointer to the last commit made on that branch.
That means HEAD will be the parent of the next commit that is created.
It's generally simplest to think of HEAD as the snapshot of *your last commit*.

In fact, it's pretty easy to see what that snapshot looks like.
Here is an example of getting the actual directory listing and SHA-1 checksums for each file in the HEAD snapshot:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

The `cat-file` and `ls-tree` commands are ``plumbing'' commands that are used for lower level things and not really used in day-to-day work, but they help us see what's going on here.

[[_the_index]]
===== The Index

The Index is your *proposed next commit*. We've also been referring to this concept as Git's ``Staging Area'' as this is what Git looks at when you run `git commit`.

Git populates this index with a list of all the file contents that were last checked out into your working directory and what they looked like when they were originally checked out.
You then replace some of those files with new versions of them, and `git commit` converts that into the tree for a new commit.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Again, here we're using `ls-files`, which is more of a behind the scenes command that shows you what your index currently looks like.

The index is not technically a tree structure – it's actually implemented as a flattened manifest – but for our purposes it's close enough.

===== The Working Directory

Finally, you have your working directory.
The other two trees store their content in an efficient but inconvenient manner, inside the `.git` folder.
The Working Directory unpacks them into actual files, which makes it much easier for you to edit them.
Think of the Working Directory as a *sandbox*, where you can try changes out before committing them to your staging area (index) and then to history.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== The Workflow

Git's main purpose is to record snapshots of your project in successively better states, by manipulating these three trees.

image::images/reset-workflow.png[]

Let's visualize this process: say you go into a new directory with a single file in it.
We'll call this *v1* of the file, and we'll indicate it in blue.
Now we run `git init`, which will create a Git repository with a HEAD reference which points to an unborn branch (`master` doesn't exist yet).

image::images/reset-ex1.png[]

At this point, only the Working Directory tree has any content.

Now we want to commit this file, so we use `git add` to take content in the Working Directory and copy it to the Index.

image::images/reset-ex2.png[]

Then we run `git commit`, which takes the contents of the Index and saves it as a permanent snapshot, creates a commit object which points to that snapshot, and updates `master` to point to that commit.

image::images/reset-ex3.png[]

If we run `git status`, we'll see no changes, because all three trees are the same.

Now we want to make a change to that file and commit it.
We'll go through the same process; first we change the file in our working directory.
Let's call this *v2* of the file, and indicate it in red.

image::images/reset-ex4.png[]

If we run `git status` right now, we'll see the file in red as ``Changes not staged for commit,'' because that entry differs between the Index and the Working Directory.
Next we run `git add` on it to stage it into our Index.

image::images/reset-ex5.png[]

At this point if we run `git status` we will see the file in green
under ``Changes to be committed'' because the Index and HEAD differ – that is, our proposed next commit is now different from our last commit.
Finally, we run `git commit` to finalize the commit.

image::images/reset-ex6.png[]

Now `git status` will give us no output, because all three trees are the same again.

Switching branches or cloning goes through a similar process.
When you checkout a branch, it changes *HEAD* to point to the new branch ref, populates your *Index* with the snapshot of that commit, then copies the contents of the *Index* into your *Working Directory*.

==== The Role of Reset

The `reset` command makes more sense when viewed in this context.

For the purposes of these examples, let's say that we've modified `file.txt` again and committed it a third time. So now our history looks like this:

image::images/reset-start.png[]

Let's now walk through exactly what `reset` does when you call it. It directly manipulates these three trees in a simple and predictable way.
It does up to three basic operations.

===== Step 1: Move HEAD

The first thing `reset` will do is move what HEAD points to.
This isn't the same as changing HEAD itself (which is what `checkout` does); `reset` moves the branch that HEAD is pointing to.
This means if HEAD is set to the `master` branch (i.e. you're currently on the `master` branch), running `git reset 9e5e64a` will start by making `master` point to `9e5e64a`.

image::images/reset-soft.png[]

No matter what form of `reset` with a commit you invoke, this is the first thing it will always try to do.
With `reset --soft`, it will simply stop there.

Now take a second to look at that diagram and realize what happened: it essentially undid the last `git commit` command.
When you run `git commit`, Git creates a new commit and moves the branch that HEAD points to up to it.
When you `reset` back to `HEAD~` (the parent of HEAD), you are moving the branch back to where it was, without changing the Index or Working Directory.
You could now update the Index and run `git commit` again to accomplish what `git commit --amend` would have done (see <<_git_amend>>).

===== Step 2: Updating the Index (--mixed)

Note that if you run `git status` now you'll see in green the difference between the Index and what the new HEAD is.

The next thing `reset` will do is to update the Index with the contents of whatever snapshot HEAD now points to.

image::images/reset-mixed.png[]

If you specify the `--mixed` option, `reset` will stop at this point.
This is also the default, so if you specify no option at all (just `git reset HEAD~` in this case), this is where the command will stop.

Now take another second to look at that diagram and realize what happened: it still undid your last `commit`, but also _unstaged_ everything.
You rolled back to before you ran all your `git add` and `git commit` commands.

===== Paso 3: Actualizando el directorio de trabajo (--hard)

La tercera cosa que `reset` hará es hacer que el Directorio de Trabajo luzca como el Índice.
Si usas la opción `--hard` , contunuará a este paso.

image::images/reset-hard.png[]

Pensemos en lo que acaba de pasar.
Acabas de deshacer tu más reciente aislamiento, los comandos  `git add` y `git commit`, **y** todo el trabajo que hiciste en tu directorio de trabajo.

Es importante notar que este marcador (`--hard`) es la unica manera de hacer el comando `reset` uno peligroso, y es uno de los pocos casos en los que Git destruirá datos.
Cualquier otra invocacion de `reset` puede ser fácilmente deshecha, pero la opción `--hard` no puede ser deshecha, ya que reescribe de forma forzada archivos en el Directorio de trabajo.
En este caso particular, aun tenemos la version *v3* de nuestro archivo en aislamiento en nuestro DB Git, y podríamos recobrarlo mirando nuestro `reflog`, pero si no lo hubiesemos aislado, Git lo hubiese reescrito y sería irrecuperable.

===== Resumen

El comando `reset` reescribe estos tres árboles en un orden específico, deteniendose cuando tú le digas:

1. Mover la rama hacia la que HEAD apunta _(Se detiene si `--soft`)_
2. Hace que el Índice luzca como HEAD _(Se detiene aquí a menos de que `--hard`)_
3. Hace que el directorio de trabajo luzca como el Índice

==== Resetear con un camino

Eso cubre el comportamiento de `reset` en su forma básica, pero también le puedes proveer un camino para que actue en el.
Si tú especifícas un camino, `reset` se saltará el paso 1 y limitará el resto de sus acciones a un archivo en específico, o un set de archivos.
Esto de hecho tiene sentido - HEAD solo es un puntero, y no puedes apuntar a una parte de un aislamiento y parte de otro.
Pero el Índice y el Directorio de Trabajo _pueden_ ser parcialmente actualizadas, así que reset procede con los pasos 2 y 3.

Así que, asumamos que corremos `git reset file.txt`.
Esta forma  (ya que no especificaste un aislamiento SHA-1 o una rama, y no especificaste si `--soft` o `--hard`) es una simplificación de `git reset --mixed HEAD file.txt`, la que:

1. Moverá la rama a la que apunta HEAD  _(omitido)_
2. Hará que el Índice luzca como HEAD _(se detiene aquí)_

Así que esencialmente sólo copia `file.txt` desde HEAD hasta el Índice.

image::images/reset-path1.png[]

This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.

image::images/reset-path2.png[]

Este es el porqué el resultado del comando `git status` sugiere que corras esto para desmontar un archivo.
(Mira en <<_unstaging>> para más información.)

Podríamos facimente evitar que Git asuma que queríamos decir ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

Esto efectivamente hace lo mismo que si hubiesemos revertido el contenido del archivo a *v1* en el Directorio de Trabajo, puesto a correr `git add` en el, y entonces haberlo revertido a *v3* de nuevo (sin hacer todos esos pasos).
Si corremos `git commit` ahora, se registrará un cambio que revertirá ese archivo de vuelta a *v1*, aunque nunca lo hayamos tenido en nuestro Directorio de Trabajo.

Es también interesante el notar que como `git add`, el comando `reset` aceptará una opción `--patch` para desmontar contenido por pedazos grandes.
Así que puedes montar o revertir contenido de forma selectiva.

==== Aplastando

Miremos como hacer algo interesante con este recien encontrado poder – aplastar aislamientos.

Digamos que tienes una serie de aislamientos con mensajes como ``oops.'', ``WIP'' y ``forgot this file''.
You can use `reset` para fácil y rápidamente aplastarlos en un solo aislamiento que te haga lucir bastante inteligente.
(<<_squashing>> muestra otra manera de hacer esto, pero en este ejemplo es más simple el usar `reset`.)

Digamos que tienes un proyecto en el que el primer aislamiento tiene un solo archivo, el segundo aislamiento añadió un nuevo archivo y cambió el primero, y el tercero cambió el primer archivo de nuevo.
El segundo aislamiento era un trabajo en proceso y tu quieres aplastarlo.

image::images/reset-squash-r1.png[]

Puedes correr `git reset --soft HEAD~2` para mover la rama HEAD a un aislamiento viejo (el primer aislamiento que te quieres quedar):

image::images/reset-squash-r2.png[]

Entonces simplemente corre `git commit` de nuevo:

image::images/reset-squash-r3.png[]

Ahora puedes ver que tu historial alcanzable, el historial al que quisieras darle un empujón, ahora luce como si tuvieras un solo aislamiento con `file-a.txt` v1, entonces un segundo que modificó `file-a.txt` a v3 y añadió `file-b.txt`. El aislamiento con la versión v2 del archivo no está más en la historia.


==== Pruebalo

Finalmente, te preguntarás cuál es la diferencia entre `checkout` y `reset`.
Muy como `reset`, `checkout` manipula los tres árboles, y es un poco diferente dependiendo de si le das al comando un camino de archivo o no.

===== Sin caminos

Correr `git checkout [branch]` es bastante similar a correr `git reset --hard [branch]` en ella se actualizan los tres árboles para que luzcan como `[branch]`, pero allí hay dos diferencias importantes.

Primero, a diferencia de `reset --hard`, `checkout` es segura para el directorio de trabajo; chequeara para estar seguro de que no está eliminando archivos que tienen cambios en ellos.
De hecho, es un poco más inteligente que eso – trata de hacer una fusión tribal en el Directorio de Trabajo, así que todos los archivos que _no_ han cambiado, serán actualizados.
`reset --hard`, por otra parte, simplemente reemplazará todo lo que esté en el tablero sin chequearlo.

La segunda importante diferencia es como actualiza HEAD.
Donde `reset` moverá la rama a la que HEAD apunta, `checkout` moverá HEAD para que apunte a otra rama.

Por ejemplo, digamos que tenemos las ramas `master` y `develop` que apuntan a diferentes aislamientos, y estamos actualmente en `develop` (así que HEAD apunta allí).
Si corremos `git reset master`, `develop` mismo ahora mirará al mismo aislamiento que `master`.
Si en cambio corrieramos `git checkout master`, `develop` no se mueve, HEAD lo hace.
HEAD ahora apuntará a `master`.

Así que, en ambos casos estamos moviendo HEAD para que apunte a un aislamiento A, pero _como_ lo hacemos es bastante diferente.
`reset` moverá la rama a la que HEAD apunta, `checkout` mueve HEAD.

image::images/reset-checkout.png[]

===== Con caminos

La otra manera de correr `checkout` es con un camino de archivos, porque, como `reset`, no mueve HEAD.
Es justo como `git reset [branch] file` ya que actualiza el indice con ese archivo que aisla, pero también reescribe el archivo en el directorio de trabajo.
Sería exactamente como `git reset --hard [branch] file` (si `reset` te dejase correr eso) – no es seguro para trabajar en el directorio de trabajo, y no mueve HEAD.

También, como `git reset` y `git add`, `checkout` aceptará una opción `--patch` para permetirte de forma selectiva el revertir contenidos de archivos por pedazos grandes.

==== Resumen

Afortunadamente ahora entiendes y te sientes más cómodo con el comando `reset`, pero aun estás un poco confundido sobre como se diferencia de `checkout` y posiblemente no podrías recordar todas las reglas de las diferentes invocaciones.

Aquí tenemos una hoja de trampas para saber qué comandos afectan a cuáles arboles.
La columna ``HEAD'' lee ``REF'' si ese comando mueve la referencia (rama) a la que HEAD apunta, y ``HEAD'' si mueve HEAD.
Presta atención a la columna 'WD Safe?' – si dice *NO*, tomate un segundo para pensar antes de correr ese comando.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================
