[[_rewriting_history]]
Reescribiendo la historia

Muchas veces, al trabajar con Git, vas a querer confirmar tu historia por alguna razón. 
Una de las grandes cualidades de Git es que te permite tomar decisiones en el último momento.
Puede decidir qué archivos entran en juego antes de comprometerse con el área de ensayo, puedes decidir que no querías estar trabajando en algo todavía con el comando de alijos, y puedes reescribir confirmaciones que ya hayan pasado haciendo parecer que fueron hechos de diferente manera.
Esto puede desenvolverse en el cambio de las confirmaciones, cambiando mensajes o modificando los archivos en un cometido, aplastando o dividiendo confirmaciones enteramente – todo antes de que compartas tu trabajo con otras personas.

En esta sección, verás cómo complementar esas tareas tan útiles que harán parece que la confirmación de tu historia parezca del modo en el cual quisiste compartirla.

[[_git_amend]]
==== Cambiando la última confirmación  

Cambiar la última confirmación es probablemente lo más común que le harás a tu historia. 
Comúnmente querrás hacer dos cosas en tu ultima confirmación: cambiar la confirmación del mensaje, o cambiar la parte instantánea que acabas de agregar sumando, cambiando y removiendo archivos. 
Si solamente quieres cambiar la confirmación del mensaje final, es muy sencillo:

[source,console]
----
$ git commit --amend
----

Esto te envía al editor de texto, el cual tiene tu confirmación final, listo para modificarse en el mensaje.
Cuando guardes y cierres el editor, el editor escribe una nueva confirmación conteniendo el mensaje y lo con tu ultima confirmación.

Si ya ha cambiado su última confirmación y luego quiere cambiar la instantánea que confirmo al agregar o cambiar archivos, esto es por que posiblemente olvidó agregar un archivo recién creado cuando se confirmó originalmente, el proceso trabaja prácticamente de la misma manera.
Tu manejas los cambios que quieras editando el archivo y oprimiendo git add en este o git rm a un archivo adjunto, y el subsecuente git commit --amend toma tu área de trabajo actual y la vuelve una instantánea para la nueva confirmación.

Debes ser cuidadoso con esta técnica porque puedes modificar los cambios del SHA-1 de la confirmación
Es como un muy pequeño rebase – no necesitas modificar tu ultima confirmación si ya el haz puesto.

[[_changing_multiple]]
==== Cambiando la confirmación de múltiples mensajes

Para modificar una confirmación que está más atrás en tu historia, deberás aplicar herramientas más complejas
Git no tiene una herramienta para modificar la historia, pero puedes usar la herramienta de rebase para rebasar ciertas series confirmaciones en el HEAD en el que se basaron originalmente en lugar de moverlos a otro. 
Con la herramienta interactiva del rebase, puedes parar justo después de cada confirmación que quieras modificar y cambiar su mensaje, añadir archivos, o hacer cualquier cosa que quieras
Puedes ejecutar el rebase interactivamente agregando el `-i` option to `git rebase`.
De igual manera debes indicar que tan atrás quieres regresar para reescribir las confirmaciones escribiendo en el comando cual confirmación quieres rebasar.

Por ejemplo, si quieres cambiar las confirmaciones de los tres últimos mensajes, o cualquiera de los mensajes de confirmación de ese grupo, proporcionas un argumento para lo `git rebase -i` que quieras modificar de tu ultima confirmación, el cual es `HEAD~2^` or `HEAD~3` .
Debería ser más fácil el recordar el ~3 porque estás tratando de editar las últimas tres confirmaciones; pero ten en mente que estás designando actualmente cuatro confirmaciones atrás, la parte del ultimo cometido que deseas editar:

[source,console]
----
$ git rebase -i HEAD~3
----

Recuerda de Nuevo es este es un comando de rebase – cualquier confirmación incluida en el rango de `HEAD~3..HEAD` será reescrita, aun si cambias el mensaje o no.
No incluyas cualquier confirmación que ya hayas enviado al servidor central – si lo haces esto confundirá a los demás desarrolladores proporcionando una versión alternativa del mismo cambio.

Utilizar este comando te da una lista de las confirmaciones en tu editor de texto que se ve como este:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Es importante el notar que estas confirmaciones son escuchadas en el orden contrario de la que tú normalmente las verías usando el comando de `log`.
Si utilizaras un comando de `log`, verías algo como esto.

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Nótese que el orden esta al revés.
El rebase interactivo te da un script que va a utilizarse.
Este empezará en la confirmación que especificas en la línea de comandos (`HEAD~3`) y reproducir los cambios introducidos en cada una de estas confirmaciones de arriba a abajo. 
Este acomoda los más viejos en la parte de arriba, y va bajando hasta los más nuevos, porque ese será el primero en reproducirse

Necesitaras editar el script para que se detenga en la confirmación que quieres editar.
Para hacer eso, cambia la palabra `pick' por la frase `edit' para cada una de las confirmaciones en las que quieres que el script se detenga. 
Por ejemplo, para modificar solamente la tercera confirmación del mensaje, cambiarias el archivo para que se viera algo así:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Cuando guardes y salgas del editor, Git te enviará atrás a la última confirmación en la lisa y te llevará a la línea de comando con el siguiente mensaje:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

Estas instrucciones te dirán exactamente qué hacer.
Type

[source,console]
----
$ git commit --amend
----

Cambia la confirmación del mensaje, y sal del editor.
Then, run

[source,console]
----
$ git rebase --continue
----

Este comando te permitirá aplicar las otras dos confirmaciones automáticamente, y después de esto estás listo.
Si decides cambiar y elegir editar en más líneas, puedes repetir estos pasos para cada confirmación que cambies en cada edición.
Cada vez, Git se parará, permitiéndote modificar la confirmación y continuar cuando hayas terminado

==== Reordenando Confirmaciones

De igual manera puedes usar rebases interactivos para reordenar o remover confirmaciones enteramente.
Si quieres remover la ``added cat-file'' confirmación y cambiar el orden en el cual las otras dos confirmaciones son introducidas, puedes cambiar el rebase en el script de esto:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

A esto:


[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

Cuando guardes y salgas del editor, Git te recordará de tu rama de padres de estas confirmaciones, aplicando 310154e y después f7f3f6d, y después se parará. 
Cambias efectivamente el orden de esas confirmaciones y eliminas la “added cat-file’’ confirmación completamente.

[[_squashing]]
==== Unir confirmaciones

También es posible el tomar series de confirmaciones y unirlas todas en una sola confirmación con la herramienta interactiva de rebase.
El script pone instrucciones que en el mensaje de rebase:

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

If, instead of ``pick'' or ``edit'', you specify ``squash'', Git applies both that change and the change directly before it and makes you merge the commit messages together.
So, if you want to make a single commit from these three commits, you make the script look like this:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

When you save and exit the editor, Git applies all three changes and then puts you back into the editor to merge the three commit messages:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

When you save that, you have a single commit that introduces the changes of all three previous commits.

==== Splitting a Commit

Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of ``updated README formatting and added blame'', you want to split it into two commits: ``updated README formatting'' for the first, and ``added blame'' for the second.
You can do that in the `rebase -i` script by changing the instruction on the commit you want to split to ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.
When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (`f7f3f6d`), applies the second (`310154e`), and drops you to the console.
There, you can do a mixed reset of that commit with `git reset HEAD^`, which effectively undoes that commit and leaves the modified files unstaged.
Now you can stage and commit files until you have several commits, and run `git rebase --continue` when you’re done:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git applies the last commit (`a5f4a0d`) in the script, and your history looks like this:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

Once again, this changes the SHA-1s of all the commits in your list, so make sure no commit shows up in that list that you’ve already pushed to a shared repository.

==== The Nuclear Option: filter-branch

There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way – for instance, changing your e-mail address globally or removing a file from every commit.
The command is `filter-branch`, and it can rewrite huge swaths of your history, so you probably shouldn’t use it unless your project isn’t yet public and other people haven’t based work off the commits you’re about to rewrite.
However, it can be very useful.
You’ll learn a few of the common uses so you can get an idea of some of the things it’s capable of.

[[_removing_file_every_commit]]
===== Removing a File from Every Commit

This occurs fairly commonly.
Someone accidentally commits a huge binary file with a thoughtless `git add .`, and you want to remove it everywhere.
Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.
`filter-branch` is the tool you probably want to use to scrub your entire history.
To remove a file named passwords.txt from your entire history, you can use the `--tree-filter` option to `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the results.
In this case, you remove a file called passwords.txt from every snapshot, whether it exists or not.
If you want to remove all accidentally committed editor backup files, you can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.

You’ll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.
It’s generally a good idea to do this in a testing branch and then hard-reset your master branch after you’ve determined the outcome is what you really want.
To run `filter-branch` on all your branches, you can pass `--all` to the command.

===== Making a Subdirectory the New Root

Suppose you’ve done an import from another source control system and have subdirectories that make no sense (trunk, tags, and so on).
If you want to make the `trunk` subdirectory be the new project root for every commit, `filter-branch` can help you do that, too:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Now your new project root is what was in the `trunk` subdirectory each time.
Git will also automatically remove commits that did not affect the subdirectory.

===== Changing E-Mail Addresses Globally

Another common case is that you forgot to run `git config` to set your name and e-mail address before you started working, or perhaps you want to open-source a project at work and change all your work e-mail addresses to your personal address.
In any case, you can change e-mail addresses in multiple commits in a batch with `filter-branch` as well.
You need to be careful to change only the e-mail addresses that are yours, so you use `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

This goes through and rewrites every commit to have your new address.
Because commits contain the SHA-1 values of their parents, this command changes every commit SHA-1 in your history, not just those that have the matching e-mail address.
